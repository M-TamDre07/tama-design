<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Arena Mini Games — Tama Andrea Official</title>
<meta name="description" content="Koleksi mini-game ringan: Dino Runner, Snake Classic, Memory Match. Mainkan di desktop atau mobile untuk hiburan singkat!" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&family=Poppins:wght@700&display=swap" rel="stylesheet">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🎮</text></svg>">

<style>
  /* 1. Global Reset & Variables */
  :root {
    --color-bg-dark: #071018;
    --color-bg-light: #0d1e2a;
    --color-panel: #112836;
    --color-card: #0f202c;
    --color-accent: #00e0b8; /* Cyan-Teal */
    --color-accent-dark: #00bfa0;
    --color-muted: #9fb0aa;
    --color-text: #e8f3f8;
    --color-danger: #ff5757;
    --color-success: #4CAF50;
    --shadow-light: 0 4px 15px rgba(0, 0, 0, 0.2);
    --shadow-deep: 0 10px 30px rgba(0, 0, 0, 0.4);
    --radius-md: 10px;
    --radius-sm: 6px;
  }
  
  *, *::before, *::after {
    box-sizing: border-box;
  }
  
  html, body {
    height: 100%;
    margin: 0;
    font-family: 'Inter', system-ui, sans-serif;
    background: linear-gradient(180deg, var(--color-bg-dark), var(--color-bg-light));
    color: var(--color-text);
    line-height: 1.6;
    scroll-behavior: smooth;
  }
  
  .wrap {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
  }
  /* 2. Typography & Base Elements (Upgraded) */
h1, h2, strong {
  font-family: 'Poppins', 'Inter', sans-serif;
  color: var(--color-text);
  line-height: 1.3;
}

header {
  padding: clamp(10px, 2vw, 18px) 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  margin-bottom: clamp(16px, 2vw, 24px);
}

header h1 {
  font-size: clamp(1.4rem, 2.5vw, 2rem);
  font-weight: 800;
  margin: 0;
  letter-spacing: -0.5px;
}

.small {
  font-size: clamp(0.75rem, 1.5vw, 0.9rem);
  color: var(--color-muted);
}

/* 3. Button Component (Upgraded) */
a.btn, button.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: clamp(10px, 1.8vw, 14px) clamp(16px, 2.2vw, 22px);
  border-radius: var(--radius-md);
  border: none;
  background: linear-gradient(90deg, var(--color-accent), var(--color-accent-dark));
  color: var(--color-bg-dark);
  text-decoration: none;
  font-weight: 700;
  font-size: clamp(0.85rem, 1.8vw, 1rem);
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.3s ease, background 0.3s ease;
  box-shadow: var(--shadow-light);
}

a.btn:hover, button.btn:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: var(--shadow-deep);
}

a.btn:active, button.btn:active {
  transform: scale(0.97);
  box-shadow: none;
}

a.btn.ghost, button.btn.ghost {
  background: transparent;
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: var(--color-text);
  box-shadow: none;
}

a.btn.ghost:hover, button.btn.ghost:hover {
  background: rgba(255, 255, 255, 0.06);
  border-color: var(--color-accent);
}

/* 4. Layout Structure (Upgraded) */
.header-content {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  flex-wrap: wrap;
}

main {
  display: grid;
  grid-template-columns: 320px 1fr;
  gap: clamp(20px, 3vw, 30px);
  margin-top: 20px;
}

@media (max-width: 992px) {
  main {
    grid-template-columns: 1fr;
    gap: 20px;
  }
}

/* 5. Panel/Aside Component (Upgraded with Glassmorphism) */
.panel {
  background: rgba(17, 40, 54, 0.75);
  backdrop-filter: blur(10px);
  padding: clamp(16px, 2vw, 22px);
  border-radius: var(--radius-md);
  border: 1px solid rgba(255, 255, 255, 0.08);
  box-shadow: var(--shadow-deep);
  transition: transform 0.3s ease, background 0.3s ease;
}

/* Game List (Upgraded) */
.game-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 15px;
}

.game-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px 14px;
  border-radius: var(--radius-sm);
  cursor: pointer;
  background: var(--color-card);
  border: 2px solid transparent;
  transition: all 0.25s ease;
  user-select: none;
}

.game-item:hover {
  background: rgba(255, 255, 255, 0.06);
  border-color: var(--color-accent-dark);
  transform: translateX(4px);
}

.game-item.active {
  background: var(--color-accent);
  color: var(--color-bg-dark);
  font-weight: 700;
  box-shadow: var(--shadow-light);
  border-color: var(--color-accent);
  transform: scale(1.02);
}

.game-item.active .small {
  color: rgba(0, 0, 0, 0.75);
  font-weight: 600;
}

.game-item__indicator {
  margin-left: auto;
  font-size: 0.85rem;
  padding: 3px 8px;
  border-radius: 6px;
  background: rgba(0, 0, 0, 0.15);
}
  /* 6. Stage/Game Area Component (Upgraded) */
.stage {
  background: rgba(15, 32, 44, 0.85);
  backdrop-filter: blur(8px);
  border-radius: var(--radius-md);
  padding: clamp(16px, 2vw, 24px);
  border: 1px solid rgba(255, 255, 255, 0.08);
  min-height: 400px;
  position: relative;
  box-shadow: var(--shadow-deep);
  transition: background 0.3s ease, transform 0.3s ease;
}

.stage:hover {
  transform: translateY(-2px);
}

/* HUD (Header atas skor & status) */
.hud {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 15px;
  margin-bottom: 18px;
  padding: 10px 0 14px;
  border-bottom: 1px dashed rgba(255, 255, 255, 0.15);
  background: rgba(255, 255, 255, 0.02);
  border-radius: var(--radius-sm);
}

/* Skor lebih menonjol */
.score {
  font-size: clamp(1.2rem, 2.5vw, 1.6rem);
  font-weight: 800;
  color: var(--color-accent);
  font-family: 'Poppins', monospace;
  text-shadow: 0 0 6px rgba(0, 224, 184, 0.4);
  animation: scorePulse 2s infinite ease-in-out;
}

@keyframes scorePulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

/* Controls area */
.controls {
  display: flex;
  gap: 12px;
  align-items: center;
  font-size: 0.9rem;
  color: var(--color-muted);
}

/* Canvas wrapper lebih immersive */
.canvas-wrap {
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.06));
  border-radius: var(--radius-md);
  padding: clamp(6px, 1vw, 12px);
  min-height: 320px;
  box-shadow: inset 0 0 35px rgba(0, 0, 0, 0.45);
  transition: box-shadow 0.3s ease, transform 0.3s ease;
}

.canvas-wrap:hover {
  box-shadow: inset 0 0 40px rgba(0, 224, 184, 0.15), 0 0 12px rgba(0, 224, 184, 0.25);
  transform: scale(1.01);
}

/* Canvas responsif */
canvas {
  background: var(--color-bg-dark);
  border-radius: var(--radius-sm);
  display: block;
  width: 100%;
  height: auto;
  max-height: 70vh;
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
}
  /* 7. Mobile Controls (Upgraded) */
.mobile-controls {
  display: none; /* Default hidden, ditampilkan via media query */
  gap: 14px;
  margin-top: 22px;
  justify-content: center;
  flex-wrap: wrap;
  user-select: none;
  padding: 8px;
}

.mobile-controls button {
  width: clamp(50px, 12vw, 70px);
  height: clamp(50px, 12vw, 70px);
  border-radius: 50%;
  border: 2px solid var(--color-accent-dark);
  background: linear-gradient(145deg, rgba(255,255,255,0.08), rgba(0,0,0,0.2));
  color: var(--color-accent);
  font-size: clamp(1rem, 5vw, 1.4rem);
  font-weight: 700;
  transition: 
    background 0.2s ease, 
    color 0.2s ease, 
    transform 0.15s ease,
    box-shadow 0.2s ease;
  touch-action: manipulation;
  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
}

.mobile-controls button:hover {
  background: rgba(0, 224, 184, 0.15);
  box-shadow: 0 6px 14px rgba(0, 224, 184, 0.25);
}

.mobile-controls button:active {
  background: var(--color-accent);
  color: var(--color-bg-dark);
  transform: scale(0.92);
  box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
}

@media (max-width: 768px) {
  .mobile-controls {
    display: flex;
  }
}

  /* 8. Info/Instruction Block */
  .info-block {
    padding: 15px;
    border-radius: var(--radius-sm);
    background: rgba(255, 255, 255, 0.03);
    font-size: 0.95rem;
    border-left: 4px solid var(--color-accent);
    margin-top: 15px;
  }
  
  /* 9. Memory Grid Specific */
  .grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
    padding: 15px;
    max-width: 480px; /* Centralize grid */
    margin: 20px auto 0;
  }

  .card-tile {
    aspect-ratio: 1/1;
    border-radius: var(--radius-md);
    background: var(--color-panel);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    cursor: pointer;
    user-select: none;
    box-shadow: var(--shadow-light);
    transition: transform 0.3s, background 0.3s;
    transform-style: preserve-3d;
    perspective: 1000px;
    border: 1px solid rgba(255, 255, 255, 0.05);
  }

  .card-tile:hover {
    transform: scale(1.03);
  }

  .card-tile.revealed {
    background: var(--color-accent);
    color: var(--color-bg-dark);
    box-shadow: var(--shadow-deep);
  }

  .card-tile.matched {
    background: var(--color-success);
    color: var(--color-text);
    cursor: default;
    opacity: 0.9;
    animation: match-pulse 0.5s ease-out;
  }

  @keyframes match-pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }

/* ====================================================================
   [10] Toast Notification - Upgraded
   ==================================================================== */
.toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%) translateY(0);
  bottom: -80px; /* Off-screen start */
  background: var(--color-accent);
  color: var(--color-bg-dark);
  padding: 14px 24px;
  border-radius: var(--radius-lg);
  box-shadow: 0 8px 20px rgba(0,0,0,0.25);
  z-index: 9999;
  opacity: 0;
  font-weight: 700;
  font-size: 1rem;
  line-height: 1.4;
  transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s ease;
  pointer-events: none; /* prevent accidental clicks when hidden */
  max-width: 90%;
  text-align: center;
}

/* Show toast */
.toast.show {
  bottom: 30px;
  transform: translateX(-50%) translateY(-10px); /* slight upward pop */
  opacity: 1;
  pointer-events: auto;
}

/* Optional: Responsive font scaling */
@media (max-width: 480px) {
  .toast {
    font-size: 0.875rem;
    padding: 12px 18px;
  }
}

/* ====================================================================
   [11] Footer - Upgraded
   ==================================================================== */
footer.small {
  margin-top: 30px;
  text-align: center;
  padding: 14px 10px 10px 10px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  font-size: 0.875rem;
  font-weight: 400;
  color: rgba(255, 255, 255, 0.6);
  line-height: 1.5;
  letter-spacing: 0.5px;
}

@media (max-width: 480px) {
  footer.small {
    font-size: 0.8rem;
    padding-top: 12px;
  }
}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="header-content">
      <h1><span style="color:var(--color-accent)">🎮</span> Arena Mini Games</h1>
      <div class="top-actions">
        <a href="index.html" class="btn ghost" title="Kembali ke beranda">← Beranda</a>
        <a href="profile.html" class="btn" title="Kunjungi Profil Tama">👤 Profil</a>
      </div>
    </div>
  </header>

  <main>
    <aside class="panel" aria-label="Menu Permainan dan Kontrol">
      <div style="display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid rgba(255,255,255,0.1);padding-bottom:10px">
        <div>
          <strong>Pilih Game</strong>
          <div class="small">Mainkan di browser, mendukung sentuhan & keyboard.</div>
        </div>
      </div>
      
      <div class="game-list" id="gameList">
        <div class="game-item active" data-game="dino" id="gi-dino">
          <strong>🦖 Dino Runner</strong>
          <div class="game-item__indicator small">Lompat</div>
        </div>
        <div class="game-item" data-game="snake" id="gi-snake">
          <strong>🐍 Snake Classic</strong>
          <div class="game-item__indicator small">Bertahan</div>
        </div>
        <div class="game-item" data-game="memory" id="gi-memory">
          <strong>🃏 Memory Match</strong>
          <div class="game-item__indicator small">Pasangkan</div>
        </div>
      </div>
      
      <div style="margin-top: 20px;">
        <div style="text-align:left; margin-bottom: 8px;">
          <div class="small">🏆 **Best Scores:**</div>
          <div id="bestScores" style="font-size: 0.95rem; font-weight: 600;" aria-live="polite">Dino:0 • Snake:0 • Memory:0</div>
        </div>
      </div>

      <div style="margin-top:14px;display:flex;gap:10px">
        <button id="btnStart" class="btn" style="flex-grow:1">Mulai Bermain</button>
        <button id="btnPause" class="btn ghost" style="width:100px;">Pause</button>
      </div>

      <div class="small info-block" id="instructions">
        <strong>Instruksi:</strong> Tekan **Spasi** untuk lompat (Dino), gunakan **Panah** untuk bergerak (Snake), dan **Ketuk/Klik** kartu (Memory). Gunakan tombol di bawah area game untuk mobile.
      </div>
      
      <div style="margin-top:15px" class="small">
        <label>
          <input type="checkbox" id="soundToggle" checked> 🔉 Efek Suara (Opsional)
        </label>
      </div>
    </aside>

    <section class="stage" aria-live="polite">
      <div class="hud">
        <div class="score-container">
          <span class="small">SKOR AKTIF</span>
          <div class="score" id="scoreLabel">0</div>
        </div>
        <div class="controls">
          <div id="statusLabel" class="small">Status: Siap</div>
        </div>
      </div>

      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="gameCanvas" width="800" height="320" style="max-width:100%;width:100%;height:auto"></canvas>
      </div>

      <div class="mobile-controls" id="mobileControls" aria-hidden="true">
        <button id="m-left" aria-label="Gerak Kiri">◀</button>
        <button id="m-up" aria-label="Gerak Atas">▲</button>
        <button id="m-right" aria-label="Gerak Kanan">▶</button>
        <button id="m-action" aria-label="Aksi/Lompat">⚡</button>
      </div>

      <div id="gameArea" style="margin-top:12px">
        </div>
      
      <footer>
        <p class="small">© 2025 Tama Andrea Official. Best score disimpan di Local Storage browser Anda. Tekan 'P' untuk Jeda cepat.</p>
      </footer>
    </section>
  </main>
</div>

<div class="toast" id="toast">Pesan</div>

<script>
/* ====================================================================
   [1] GLOBAL UTILITIES & UI BINDINGS
   ==================================================================== */
const UI = {
  canvas: document.getElementById('gameCanvas'),
  ctx: document.getElementById('gameCanvas').getContext('2d', { alpha: true }),
  gameListEls: document.querySelectorAll('.game-item'),
  scoreLabel: document.getElementById('scoreLabel'),
  statusLabel: document.getElementById('statusLabel'),
  bestScoresDisplay: document.getElementById('bestScores'),
  btnStart: document.getElementById('btnStart'),
  btnPause: document.getElementById('btnPause'),
  gameArea: document.getElementById('gameArea'),
  mobileControls: document.getElementById('mobileControls'),
  toast: document.getElementById('toast'),
  soundToggle: document.getElementById('soundToggle'),
  instructions: document.getElementById('instructions'),
  canvasWrap: document.getElementById('canvasWrap'),
};

let activeGame = 'dino';
let running = false;
let paused = false;
let animationId = null; // Used by requestAnimationFrame or setTimeout

// --- Score & Storage ---
function getBestScores() {
  return {
    dino: parseInt(localStorage.getItem('best_dino') || '0', 10),
    snake: parseInt(localStorage.getItem('best_snake') || '0', 10),
    memory: parseInt(localStorage.getItem('best_memory') || '0', 10)
  };
}

function renderBestScores() {
  const b = getBestScores();
  UI.bestScoresDisplay.textContent = `Dino:${b.dino} • Snake:${b.snake} • Memory:${b.memory}`;
}

function saveBestScore(key, score) {
  const keyMap = { dino: 'best_dino', snake: 'best_snake', memory: 'best_memory' };
  const k = keyMap[key];
  if (!k) return;
  const prev = parseInt(localStorage.getItem(k) || '0', 10) || 0;
  if (score > prev) {
    localStorage.setItem(k, score);
    showToast(`REKOR BARU! ${key.toUpperCase()}: ${score}`, 2500);
  }
}

// --- Toast & Sound ---
function showToast(text, ms = 1800) {
  UI.toast.textContent = text;
  UI.toast.classList.add('show');
  setTimeout(() => UI.toast.classList.remove('show'), ms);
}

function playBeep(gameOver = false) {
  if (!UI.soundToggle.checked) return;
  try {
    const ctxAudio = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctxAudio.createOscillator();
    const g = ctxAudio.createGain();
    o.type = gameOver ? 'sawtooth' : 'sine';
    o.frequency.value = gameOver ? 180 : 880; // Lower pitch for game over
    g.gain.value = 0.05;
    o.connect(g); g.connect(ctxAudio.destination);
    o.start();
    setTimeout(() => { o.stop(); ctxAudio.close(); }, gameOver ? 400 : 80);
  } catch (e) { console.error("Audio error:", e); }
}

// --- Drawing Helpers ---
function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (typeof r === 'undefined') r = 6;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (fill) { ctx.fill(); }
  if (stroke) { ctx.stroke(); }
}

function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
  return !(x2 > x1 + w1 || x2 + w2 < x1 || y2 > y1 + h1 || y2 + h2 < y1);
}

// --- Game Selector & UI State ---
function switchGame(g) {
  stopGame();
  
  // Update UI selection
  UI.gameListEls.forEach(x => x.classList.remove('active'));
  document.querySelector(`[data-game="${g}"]`).classList.add('active');
  activeGame = g;
  UI.statusLabel.textContent = 'Status: Siap';
  UI.scoreLabel.textContent = '0';
  UI.gameArea.innerHTML = '';
  
  // Adjust canvas/game area based on game type
  UI.canvas.style.display = 'block';
  UI.mobileControls.style.display = 'flex';
  UI.canvasWrap.style.minHeight = '320px';

  let instText = '';
  
  if (g === 'dino') {
    UI.canvas.width = 800;
    UI.canvas.height = 320;
    UI.canvas.style.maxHeight = '50vh';
    instText = 'Tekan **Spasi** untuk melompat dan hindari kaktus. Kecepatan akan terus bertambah!';
  } else if (g === 'snake') {
    UI.canvas.width = 480;
    UI.canvas.height = 480;
    UI.canvas.style.maxHeight = '75vh';
    instText = 'Gunakan **Panah** untuk mengontrol ular dan makan buah. Bertabrakan dengan dinding atau ekor akan mengakhiri permainan.';
  } else if (g === 'memory') {
    UI.canvas.style.display = 'none';
    UI.mobileControls.style.display = 'none';
    UI.canvasWrap.style.minHeight = '100px'; // Less space needed
    instText = 'Temukan semua pasangan kartu yang sama. Skor dihitung berdasarkan jumlah langkah (semakin sedikit, semakin baik!).';
    Memory.buildGrid();
  }
  
  UI.instructions.innerHTML = `<strong>Instruksi:</strong> ${instText} Pada mobile, gunakan tombol di bawah area game.`;
}

// --- Global Control Bindings ---
UI.gameListEls.forEach(el => {
  el.addEventListener('click', () => switchGame(el.getAttribute('data-game')));
});

UI.btnStart.addEventListener('click', () => {
  if (!running) {
    startGame();
    UI.btnStart.textContent = 'Restart';
  } else {
    restartGame();
  }
});

UI.btnPause.addEventListener('click', () => {
  if (!running) return;
  togglePause();
});

// --- Mobile Control Bindings ---
function sendMobileCommand(cmd) {
  if (activeGame === 'dino') {
    if ((cmd === 'up' || cmd === 'action') && running && !paused) Dino.jump();
  } else if (activeGame === 'snake') {
    if (!running || paused) return;
    if (cmd === 'left') Snake.changeDir(-1, 0);
    if (cmd === 'right') Snake.changeDir(1, 0);
    if (cmd === 'up') Snake.changeDir(0, -1);
    if (cmd === 'action') Snake.changeDir(0, 1); // Action for down in snake
  } else if (activeGame === 'memory') {
    // No mobile controls needed, click on cards
    showToast('Ketuk kartu untuk bermain Memory Match', 1000);
  }
}

document.getElementById('m-left').addEventListener('touchstart', (e) => { e.preventDefault(); sendMobileCommand('left'); });
document.getElementById('m-right').addEventListener('touchstart', (e) => { e.preventDefault(); sendMobileCommand('right'); });
document.getElementById('m-up').addEventListener('touchstart', (e) => { e.preventDefault(); sendMobileCommand('up'); });
document.getElementById('m-action').addEventListener('touchstart', (e) => { e.preventDefault(); sendMobileCommand('action'); });


/* ====================================================================
   [2] GAME ENGINE CORE (Abstracted Modules)
   ==================================================================== */

// --- Dino Runner Module ---
const Dino = (function() {
  const CONFIG = {
    PLAYER_SIZE: 28,
    PLAYER_X: 50,
    GROUND_OFFSET: 28,
    GRAVITY: 0.9,
    JUMP_VELOCITY: -13,
    INITIAL_SPEED: 4,
    SPEED_INCREMENT: 0.4,
    SCORE_MULTIPLIER: 6,
    SPAWN_RANGE: [60, 140]
  };
  
  let x, y, vy, groundY;
  let obstacles = [];
  let spawnTimer = 0;
  let spawnInterval = 90;
  let speed = CONFIG.INITIAL_SPEED;
  let score = 0;
  let runningLocal = false;

  function reset() {
    groundY = UI.canvas.height - CONFIG.GROUND_OFFSET;
    x = CONFIG.PLAYER_X;
    y = 0; // Relative to ground
    vy = 0;
    obstacles = [];
    spawnTimer = 0;
    spawnInterval = 90;
    speed = CONFIG.INITIAL_SPEED;
    score = 0;
    runningLocal = true;
    UI.ctx.clearRect(0, 0, UI.canvas.width, UI.canvas.height);
  }

  function jump() {
    // Only jump if on ground (y is 0)
    if (y >= 0 && vy === 0) {
      vy = CONFIG.JUMP_VELOCITY;
      playBeep();
    }
  }

  function spawnObstacle() {
    const h = 20 + Math.random() * 40;
    const w = 12 + Math.random() * 18;
    obstacles.push({ x: UI.canvas.width + 20, y: groundY - h, w, h });
  }

  function update() {
    // Physics: Apply gravity
    vy += CONFIG.GRAVITY;
    y += vy;
    if (y > 0) {
      y = 0;
      vy = 0;
    } // Landed

    // Obstacles movement & spawning
    obstacles.forEach(o => o.x -= speed);
    obstacles = obstacles.filter(o => o.x + o.w > -50); // Clean up off-screen
    
    spawnTimer++;
    if (spawnTimer > spawnInterval) {
      spawnTimer = 0;
      spawnInterval = CONFIG.SPAWN_RANGE[0] + Math.floor(Math.random() * (CONFIG.SPAWN_RANGE[1] - CONFIG.SPAWN_RANGE[0]));
      spawnObstacle();
    }

    // Scoring & Difficulty
    score++;
    if (score % 600 === 0) { // Every 100 actual score points
      speed += CONFIG.SPEED_INCREMENT;
      showToast(`Kecepatan Naik! (${speed.toFixed(1)}x)`);
    }
  }

  function draw() {
    UI.ctx.clearRect(0, 0, UI.canvas.width, UI.canvas.height);

    // Ground
    UI.ctx.fillStyle = 'rgba(255,255,255,0.1)';
    UI.ctx.fillRect(0, UI.canvas.height - CONFIG.GROUND_OFFSET, UI.canvas.width, CONFIG.GROUND_OFFSET);

    // Dino (Player) position calculation
    const dx = x;
    const dy = groundY - CONFIG.PLAYER_SIZE + y; // y is negative while jumping
    
    // Draw Dino
    UI.ctx.fillStyle = 'var(--color-text)';
    roundRect(UI.ctx, dx, dy, CONFIG.PLAYER_SIZE + 8, CONFIG.PLAYER_SIZE, 6, true, false);
    // Foot/Detail
    UI.ctx.fillStyle = 'var(--color-accent)';
    roundRect(UI.ctx, dx + 4, dy + CONFIG.PLAYER_SIZE - 4, 8, 4, 2, true, false);

    // Draw Obstacles
    UI.ctx.fillStyle = 'var(--color-danger)';
    obstacles.forEach(o => {
      roundRect(UI.ctx, o.x, o.y, o.w, o.h, 4, true, false);
    });
  }

  function collisionCheck() {
    const dx = x, dy = groundY - CONFIG.PLAYER_SIZE + y;
    for (const o of obstacles) {
      if (rectIntersect(dx, dy, CONFIG.PLAYER_SIZE + 8, CONFIG.PLAYER_SIZE, o.x, o.y, o.w, o.h)) {
        return true;
      }
    }
    return false;
  }

  function step() {
    if (!runningLocal || paused) return;

    update();
    draw();
    
    const currentScore = Math.floor(score / CONFIG.SCORE_MULTIPLIER);
    UI.scoreLabel.textContent = currentScore;

    if (collisionCheck()) {
      playBeep(true);
      runningLocal = false;
      running = false; // Global stop
      cancelAnimationFrame(animationId);
      UI.statusLabel.textContent = 'Status: Game Over! 😭';
      saveBestScore('dino', currentScore);
      renderBestScores();
      showToast('Game Over — Dino Runner!');
      return;
    }

    animationId = requestAnimationFrame(step);
  }

  return { 
    start: reset, 
    stop: () => { runningLocal = false; }, 
    step, 
    jump 
  };
})();

// --- Snake Module ---
const Snake = (function() {
  const GRID_SIZE = 24; // Increased grid size for better visibility
  let cols, rows;
  let snake = [];
  let dir = { x: 1, y: 0 };
  let food = null;
  let score = 0;
  let alive = true;
  const GAME_TICK_MS = 100; // Faster tick

  function reset() {
    cols = Math.floor(UI.canvas.width / GRID_SIZE);
    rows = Math.floor(UI.canvas.height / GRID_SIZE);
    snake = [{ x: Math.floor(cols / 2), y: Math.floor(rows / 2) }];
    dir = { x: 1, y: 0 };
    score = 0;
    alive = true;
    placeFood();
    UI.ctx.clearRect(0, 0, UI.canvas.width, UI.canvas.height);
  }

  function placeFood() {
    let f;
    do {
      f = { x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows) };
    } while (snake.some(s => s.x === f.x && s.y === f.y));
    food = f;
  }

  function changeDir(x, y) {
    // Prevent reversing
    if (snake.length > 1 && (snake[0].x + x === snake[1].x && snake[0].y + y === snake[1].y)) return;
    // Prevent changing from X to X or Y to Y unless at start
    if (dir.x !== 0 && x !== 0) return;
    if (dir.y !== 0 && y !== 0) return;
    dir = { x, y };
  }

  function update() {
    if (!alive) return;
    
    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
    
    // Wall wrap logic
    if (head.x < 0) head.x = cols - 1;
    if (head.x >= cols) head.x = 0;
    if (head.y < 0) head.y = rows - 1;
    if (head.y >= rows) head.y = 0;

    // Self-collision check
    if (snake.some(s => s.x === head.x && s.y === head.y)) { alive = false; return; }
    
    snake.unshift(head);

    // Food check
    if (head.x === food.x && head.y === food.y) {
      score += 10;
      playBeep();
      placeFood();
    } else {
      snake.pop(); // Remove tail if no food eaten
    }
  }

  function draw() {
    UI.ctx.clearRect(0, 0, UI.canvas.width, UI.canvas.height);
    
    // Draw Food (Fruit Emoji-style)
    UI.ctx.fillStyle = '#ffcf59';
    roundRect(UI.ctx, food.x * GRID_SIZE + 2, food.y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4, 6, true, false);
    
    // Draw Snake
    snake.forEach((s, i) => {
      // Head is white, body is accent
      UI.ctx.fillStyle = (i === 0) ? 'var(--color-text)' : 'var(--color-accent-dark)';
      roundRect(UI.ctx, s.x * GRID_SIZE + 1, s.y * GRID_SIZE + 1, GRID_SIZE - 2, GRID_SIZE - 2, 4, true, false);
    });
  }

  function step() {
    if (!alive || paused) return;
    
    update();
    draw();
    
    UI.scoreLabel.textContent = score;

    if (!alive) {
      playBeep(true);
      running = false;
      UI.statusLabel.textContent = 'Status: Game Over! 💀';
      saveBestScore('snake', score);
      renderBestScores();
      showToast('Game Over — Snake Classic!');
      return;
    }
    
    animationId = setTimeout(() => requestAnimationFrame(step), GAME_TICK_MS);
  }

  return { 
    start: reset, 
    stop: () => { alive = false; }, 
    step, 
    changeDir 
  };
})();

// --- Memory Match Module (DOM-based) ---
Memory = (function() {
  const SYMBOLS = ['🍎', '🍌', '🍇', '🍒', '🍋', '🍓', '🍉', '🍑'];
  let deck = [];
  let firstCard = null;
  let secondCard = null;
  let lock = false;
  let matches = 0;
  let moves = 0;

  function reset() {
    deck = SYMBOLS.concat(SYMBOLS).sort(() => Math.random() - 0.5);
    firstCard = secondCard = null;
    lock = false;
    matches = 0;
    moves = 0;
  }

  function flipTile(el, idx) {
    if (lock || el.classList.contains('matched') || el.classList.contains('revealed')) return;
    
    el.classList.add('revealed');
    el.textContent = deck[idx];
    playBeep(false);

    if (!firstCard) {
      firstCard = { el, idx };
      return;
    }
    
    secondCard = { el, idx };
    lock = true;
    moves++;
    UI.scoreLabel.textContent = moves;

    if (deck[firstCard.idx] === deck[secondCard.idx]) {
      // Match!
      firstCard.el.classList.add('matched');
      secondCard.el.classList.add('matched');
      firstCard.el.classList.remove('revealed');
      secondCard.el.classList.remove('revealed');
      matches++;
      firstCard = secondCard = null;
      lock = false;

      if (matches === SYMBOLS.length) {
        // Game Won!
        running = false;
        const score = Math.max(0, 100 - moves); // Score based on less moves
        saveBestScore('memory', score);
        renderBestScores();
        showToast(`ANDA MENANG! Skor (100 - langkah): ${score}`, 3500);
        UI.statusLabel.textContent = 'Status: Selesai! 🎉';
      }
    } else {
      // No Match
      setTimeout(() => {
        firstCard.el.classList.remove('revealed');
        secondCard.el.classList.remove('revealed');
        firstCard.el.textContent = '';
        secondCard.el.textContent = '';
        firstCard = secondCard = null;
        lock = false;
      }, 900);
    }
  }

  function buildGrid() {
    reset();
    UI.scoreLabel.textContent = moves;

    const wrapper = document.createElement('div');
    wrapper.className = 'grid';
    
    for (let i = 0; i < deck.length; i++) {
      const t = document.createElement('div');
      t.className = 'card-tile';
      t.tabIndex = 0; // Make focusable
      t.setAttribute('role', 'button');
      t.addEventListener('click', () => flipTile(t, i));
      t.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') flipTile(t, i); });
      wrapper.appendChild(t);
    }
    UI.gameArea.appendChild(wrapper);
  }
  
  // Memory is special: start/stop only affects state, no loop needed
  return { 
    start: () => { running = true; UI.scoreLabel.textContent = moves; }, 
    stop: () => { running = false; }, 
    buildGrid 
  };
})();


/* ====================================================================
   [3] GAME LIFECYCLE & INPUTS
   ==================================================================== */

function startGame() {
  if (activeGame === 'memory') {
    // Memory doesn't use the canvas loop, but we reset and mark running
    Memory.buildGrid();
    Memory.start();
    UI.statusLabel.textContent = 'Status: Bermain';
    running = true;
    paused = false;
    UI.btnPause.textContent = 'Pause';
    showToast('Memory Match dimulai!');
    return;
  }
  
  running = true;
  paused = false;
  UI.btnPause.textContent = 'Pause';
  UI.statusLabel.textContent = 'Status: Bermain';

  // Game-specific initialisation and loop call
  if (activeGame === 'dino') {
    Dino.start();
    Dino.step(); // Start the requestAnimationFrame loop
  } else if (activeGame === 'snake') {
    Snake.start();
    Snake.step(); // Start the setTimeout->requestAnimationFrame loop
  }
}

function restartGame() {
  stopGame(); // Ensures clean shutdown
  startGame(); // Start fresh
  showToast(`${activeGame.toUpperCase()} di-Restart!`);
}

function togglePause() {
  if (!running) return;
  paused = !paused;
  UI.btnPause.textContent = paused ? 'Resume' : 'Pause';
  UI.statusLabel.textContent = paused ? 'Status: Jeda' : 'Status: Bermain';
  
  if (paused) {
    if (activeGame !== 'memory') cancelAnimationFrame(animationId);
  } else {
    if (activeGame === 'dino') Dino.step();
    else if (activeGame === 'snake') Snake.step();
    else if (activeGame === 'memory') showToast('Melanjutkan Memory Match...');
  }
}

function stopGame() {
  if (activeGame !== 'memory') {
    if (activeGame === 'dino') Dino.stop();
    else if (activeGame === 'snake') Snake.stop();
    UI.ctx.clearRect(0, 0, UI.canvas.width, UI.canvas.height);
  }
  running = false;
  paused = false;
  cancelAnimationFrame(animationId);
  clearTimeout(animationId); // For snake
  UI.btnStart.textContent = 'Mulai Bermain';
  UI.btnPause.textContent = 'Pause';
  UI.statusLabel.textContent = 'Status: Siap';
}

// --- Keyboard Handler (Global) ---
window.addEventListener('keydown', (e) => {
  // Prevent default scroll behavior for space and arrows
  if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
    e.preventDefault();
  }

  if (!running || paused) {
    // Quick pause toggle even when not running, but only if there was a game
    if (e.key === 'p' && (activeGame !== 'memory' || running)) togglePause(); 
    return; 
  }

  if (activeGame === 'dino' && (e.key === ' ' || e.key === 'ArrowUp')) Dino.jump();

  if (activeGame === 'snake') {
    if (e.key === 'ArrowLeft') Snake.changeDir(-1, 0);
    else if (e.key === 'ArrowRight') Snake.changeDir(1, 0);
    else if (e.key === 'ArrowUp') Snake.changeDir(0, -1);
    else if (e.key === 'ArrowDown') Snake.changeDir(0, 1);
  }

  if (e.key === 'p') togglePause();
});

// Dino jump quick bind on canvas tap
UI.canvas.addEventListener('click', (e) => {
  if (activeGame === 'dino' && running && !paused) Dino.jump();
  else if (activeGame !== 'memory') showToast('Tekan tombol "Mulai" untuk bermain!', 1000);
});


/* ====================================================================
   [4] INITIALIZATION
   ==================================================================== */

// Initial setup
switchGame(activeGame); // Load Dino default
renderBestScores();
</script>
</body>
</html>
